## Branches
- **Main** - Most up to date code, used for production
- **release**
	- Created from develop to prepare for a new version for production
	- Used for final bug fixes and polishing
	- Merged into **main** and **development**
- **development**
	- Integration branch for all the features
	- Stable enough for further development though not production ready
- **feature**
	- Used for individual features of tasks
	- Merged into **development**
## Write commit subjects in the imperative mood
Write imperative commit subjects, e.g. "Fix bug" rather than "Fixed bug" or "Fixes bug." This convention matches up with commit messages generated by commands like `git merge` and `git revert`.

Tip: if you've done it correctly, the commit subject will complete the sentence, "**If merged, this commit will...**"

## ## Do only one thing with each commit
Express a single thought with each commit. This can result in very small commits (e.g. fixing a typo) or quite large ones (e.g. moving many modules to different package). The point is that a reviewer should be able to hold the commit in their head without too much trouble.

What constitutes 'a single thought' is a judgement call. You may choose to add several interdependent Django models in a single commit, as it makes sense to be reviewed as a single thing: in this case, the data model. You may choose to use one commit to add type annotations for an entire module, because it is ultimately driven by one thought. The golden rule is that it should make the life of the reviewer easier.

If you're writing 'change this and that' in a commit message, it's a strong indication that you should break up the commit.

## Make each commit atomic
Before a pull request merges, its commits should be self-contained (a.k.a. "atomic").

This means that after each commit:

- The test suite should pass;
- The codebase could be safely deployed to production.

So don't half-implement a feature in one commit then fix it in a later commit. Structure your pull requests so that each change keeps the codebase in a deployable state.

Tip: if you want to write a failing test and then fix it in a later commit, you can keep the test suite passing by decorating the test with `pytest.mark.xfail`.
## Don't Request A Review Until It Passes Unit Test
By default, wait for the test suite to pass before asking for a review. One of main purposes of the tests (in particular, the linting) is to save a reviewer's time by picking up on issues that would otherwise be flagged by a human.

The only exceptions to requesting a review with failing tests should be when:

- There are failing tests on the master/main branch that are unrelated to your changes. Try to rebase your branch as soon these are fixed, but it doesn't need to block a review.
- You need the reviewer's help to fix the tests or provide early feedback that you're going in the right direction. In this case, make sure the pull request is still in draft, as it isn't production ready.

In either case, mention in your pull request description why there are failing tests.

## Keep pull requests small
Avoid big pull requests. They are:

- hard to review;
- can get bogged down with too many comments;
- more likely to incur git conflicts;
- riskier to deploy.

There's no hard-and-fast rule as to what constitutes too big a pull request, but if it's running to more than a few hundred lines of code then it's probably worth breaking up.

## Ensure your reviewers have enough context
Use the pull request description to provide context so others can review it effectively.

Code changes don't usually speak for themselves. Reviewers need to understand the broader context: what are we trying to achieve? Is there anything you're unsure of? Is there any time sensitivity? And so on.

It is also important to align on the kind of review you are seeking. Do you want feedback on the fundamental approach? Do you want someone to think, in detail, about correctness? Are you unsure about whether it's safe to deploy? Unless you're getting a review from a close teammate, it can be difficult for reviewers to know what you're expecting from them. "Please review this change" is probably not enough context for many pull requests.

## Follow our standard commit message format
Capitalized, short (50 chars or less) summary

More detailed explanatory text, if necessary. Wrap it to about 72 characters or so. In some contexts, the first line is treated as the subject of an email and the rest of the text as the body. The blank line separating the summary from the body is critical (unless you omit the body entirely); tools like rebase can get confused if you run the two together.

Further paragraphs come after blank lines.

- Bullet points are okay, too
- Typically a hyphen or asterisk is used for the bullet, followed by a single space, with blank lines in between, but conventions vary here
- Use a hanging indent
